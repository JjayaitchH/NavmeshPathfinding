from heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    #parts of this algorithm were adapted from the professor's provided solution to Dijkstra's    #names that end in '_node' were changed to end with '_box' just so it made more sense to us    queue = [(0, source_point)]        distances = {}    distances[source_point] = 0    backpointers = {}    backpointers[source_point] = None    while queue:        current_dist, current_box = heappop(queue)        if current_box == destination_point:            path = [current_box]            current_back_box = backpointers[current_box]            while current_back_box is not None:                path.append[current_back_box]                current_back_box = backpointers[current_back_box]            return path[::-1]        for adj_box, adj_box_cost in mesh['adj']:            pathcost = current_dist + adj_box_cost            if adj_box not in distances or pathcost < distances[adj_box]:                distances[adj_box] = pathcost                backpointers[adj_box] = current_box                heappush(queue, (pathcost, adj_box))    return path, boxes.keys()